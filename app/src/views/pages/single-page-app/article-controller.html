<header class="docs-header">
  <h1 class="docs-heading">Controller</h1>
  <section class="docs-intro">
    <i>class Controller extends Page</i>
  </section>
  <br><br>
  <p>The controller defines what logic will be applied when route is changed.
  Every controller should be injected in the app by usin App:controller() method.
  <br>The controller class is extended with the Page, DataRg and DataRgListeners
  <br><b style="color:olive">MyController &rarr; Controller &rarr; Page &rarr; DataRg &rarr; DataRgListeners &rarr; Aux</b>

  </p>
</header>

<section class="docs-section" id="item-3-1">
  <h2 class="section-heading">Properties</h2>
  <table style="width:100%">
    <tr>
      <th>Property</th>
      <th>Description</th>
      <th>Type</th>
      <th>Default</th>
    </tr>
    <tr>
      <td>debugOpts</td>
      <td>the debug options (see below)</td>
      <td>object</td>
      <td></td>
    </tr>
    <tr>
      <td>_$scope</td>
      <td>the $scope object accumulator</td>
      <td>object</td>
      <td>{}</td>
    </tr>
  </table>

  <br><br>
  <pre><code class="language-js">
/*** default Controller debug options ***/
// Controller.js
renderHook: false,
prerenderHook: false,
visibleAll: false,
rerender: false,
scope: false,

// Page.js
loadInc: false,
loadView: false,
emptyView: false,
loadHead: false,
rgLazyjs: false,

// DataRg.js
rgFor: false,
rgRepeat: false,
rgIf: false,
rgSwitch: false,
rgElem: false,
rgEcho: false,
rgPrint: false,
rgValue: false,
rgInterpolate: false,
rgClass: false,
rgStyle: false,

// DataRgListeners.js
rgKILL: false,
rgHref: false,
rgClick: false,
rgKeyup: false,
rgChange: false,
rgEvt: false,
rgSet: false
  </code></pre>
</section>

<section class="docs-section" id="item-3-2">
  <h2 class="section-heading">Methods</h2>
  <p>Use this methods in the controller as lifecycle hooks, to rerender the view or to manipulate with the <b>$scope</b> object.</p>
	<ul class="methods">
    <h4>LifeCycle Hook Methods</h4>
    <b style="color:orange">INIT &rarr; PRERENDER &rarr; RENDER &rarr; POSTRENDER &rarr; DESTROY</b>
    <br><span style="font-size:smaller">The lifecycle hooks are methods which are related to render HTML elements with <b>data-rg-</b> attribute. The regoch SPA framework will render all elements with
    data-rg- attributes. Here is the example of one data-rg- element: <small>&lt;span data-rg-print="product.name"&gt;&lt;/span&gt;</small>
    which will set SPAN innerHTML with product.name (controller property value).</span>

    <li><i>async</i> <b>init <i>(trx :object) :Promise&lt;void&gt;</i></b>
      <p class="desc">Initialise the controller i.e. set controller properties with the initial values. Usually here are API calls used to fetch the initial values.
      <br><b>trx</b> - regoch router transitional variable (carrier)</p>
    </li>
    <li>
      <i>async</i> <b>prerender <i>(trx :object) :Promise&lt;void&gt;</i></b>
      <p class="desc">It's a controller lifecycle hook which executes the controller code before the "data-rg-..." elements are rendered.
      The <i>Page</i> methods <i>loadView, loadViews</i> should be used here to load the views.
      <br><b>trx</b> - regoch router transitional variable (carrier). See <a href="/router#item-2-2" data-rg-href>here</a>.</p>
    </li>
    <li>
      <i>async</i> <b>render <i>(trx :object) :Promise&lt;void&gt;</i></b>
      <p class="desc">Render all elements with the "data-rg-..." attribute.
      <br><b>trx</b> - regoch router transitional variable (carrier)</p>
    </li>
    <li>
      <i>async</i> <b>postrender <i>(trx :object) :Promise&lt;void&gt;</i></b>
      <p class="desc">It's a controller lifecycle hook which executes the controller code after the "data-rg-..." elements are rendered.
      In this hook the <b>$scope</b> should be set.
      <br><b>trx</b> - regoch router transitional variable (carrier)</p>
    </li>
    <li><i>async</i> <b>destroy <i>(pevent :Event) :Promise&lt;void&gt;</i></b>
      <p class="desc">Executes the controller code on destroying the controller, i.e. on <i>navig.onUrlChange</i> event.
      <br>This method will terminate all data-rg listeners activated by current controller (for example data-rg-click which listens for clicks on the element).
      This is very important to save browser's (app) memory space and to prevent memory leaks.
      <br><b>pevent</b> - the 'popstate' (back/forward buttons) or 'pushstate' (data-rg-href element click) event</p>
    </li>

    <br><br>
    <h4>Auxilary Render Methods</h4>
    <li><i>async</i>  <b>rerender <i>(controllerProp :string) :Promise&lt;void&gt;</i></b>
      <p class="desc"> Re-render the view i.e. the data-rg- elements with the controllerProp.
      For example: <i>data-rg-print="first_name"</i>, where first_name is the controllerProp.
      It will execute all DataRg methods (generators and non-generators)
      The <i>data-rg-inc</i>, <i>data-rg-view</i> and <i>DataRgListeners</i> will not be rerendered by this method.
      <br><b>controllerProp</b> - controller property name. Limit the render process only to the elements with the data-rg-...="controllerProp ..."</p>
    </li>

    <br><br>
    <h4>$scope Methods</h4>
    <li><i>set</i> <b>$scope <i>(val :any) :void</i></b>
      <p class="desc"> The <i>$scope</i> object setter. The view will be re-rendered by rerender() method.
      <br><b>val</b> - new $scope value</p>
    </li>
    <li><i>async</i>  <b>$scopeSet <i>(name :string, val :any) :void</i></b>
      <p class="desc"> Add/update the <i>$scope</i> property.  The view will be re-rendered by rerender() method.
      <br><b>name</b> - $scope property name
      <br><b>val</b> - value of the $scope property</p>
    </li>
    <li><i>get</i> <b>$scope <i>() :any</i></b>
      <p class="desc"> Get the <i>$scope</i> value. It's getter. The view will NOT be re-rendered.</p>
    </li>
    <li><b>$scopeReset <i>() :void</i></b>
      <p class="desc"> Set the <i>$scope</i> to empty object <b>{}</b>.  The view will be re-rendered by rerender() method.</p>
    </li>
  </ul>
</section>


<section class="docs-section" id="item-3-3">
  <h2 class="section-heading">renderDelay</h2>
  To ensure that all <i>data-rg-</i> elements are rendered on time there is the <b>renderDelay</b> parameter.
  It's used in the controller's <i>render()</i> hook.
  The developer can set it up when:
  <ol>
    <li>defining the route: <small>['when', '/playground/scope', 'ScopeCtrl', {renderDelay: 1300}]</small> . It's only valid for that specific route.</li>
    <li>by using APP::controllerRenderDelay() method. It's valid for all routes.</li>
  </ol>
  If none of 1) or 2) is used then default renderDelay <b>0</b> miliseconds is applied.
</section>


<section class="docs-section" id="item-3-4">
  <h2 class="section-heading">$scope</h2>
  The scope is the object which binds the HTML (view) and the JavaScript (controller). It is available for both the view and the controller.
  Every time the <b>this.$scope</b> is changed all DataRg and DataRgListeners methods are executed so the view is completely updated.
  This is similar to Angular 1 <i>$scope</i> parameter.
  <br>
  <br>Example with the $scope:
  <pre><code>
// controller
const products = await this.httpClient.askJSON('http://api.example.com/products/list');
await this.$scopeSet('products', products); // this will re-render the view explicitly, without calling rgFor() and rgPrint()


// view
&lt;tr data-rg-for="$scope.products"&gt;
  &lt;td data-rg-print="$scope.products.$i.name"&gt;&lt;/td&gt;
&lt;/tr&gt;
  </code></pre>

  <br>
  <br>Another way to do this is to call rgFor() and rgPrint() methods:
  <pre><code>
// controller
this.products = aawait this.httpClient.askJSON('http://api.example.com/products/list');
await this.rgFor('products');
this.rgPrint('products');

// view
&lt;tr data-rg-for="products"&gt;
  &lt;td data-rg-print="products.$i.name"&gt;&lt;/td&gt;
&lt;/tr&gt;
  </code></pre>
</section>


<section class="docs-section" id="item-3-5">
  <h2 class="section-heading">Example</h2>
  <pre><code class="language-javascript">
const { Controller, syslib } = require('regoch-spa');

module.exports = class HomeCtrl extends Controller {

  constructor(app) {
    super();
    this.util = syslib.util;
    this.debugOpts = {render: true, rgIf: true}
  }

  async prerender(trx) {
    console.log('HOME prerender', trx);

    this.setTitle('The Regoch Project');
    this.setDescription('The Regoch Project is bundle of developer tools and frameworks for realtime, web and mobile applications: regoch websocket server and client, single page app, database.');
    this.setKeywords('regoch, websocket, realtime, mobile applications, single page app, database');
    this.setLang('en');

    this.loadCSS([
      'https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-coy.min.css'
    ]);

    await this.loadView('#primary', 'pages/home/primary.html', 'sibling');
    this.loadViews([
      ['#top', 'pages/shared/top.html'],
      ['#main', 'pages/home/main.html'],
      ['#bottom', 'pages/home/bottom.html']
    ], true);
  }


  async postrender(trx) {
    console.log('HOME postrender', trx, this.rgListeners);

    this.lazyJS([
      'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js'
    ]);
  }


  async init(trx) {
    // MAIN CONTROLLER LOGIC GOES HERE
    this.myTest();
  }


  async destroy(elem, event) {
    // CODE TO EXECUTE WHEN URL IS CHANGED i.e. WHEN CONTROLLER IS DESTROYED
    this.unlazyJS();
  }




  myTest() {
    console.log('This is INIT test.');
  }


};
  </code></pre>
</section>



